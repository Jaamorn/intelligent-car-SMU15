#include "fuzzy.h"



int Fuzzy_kp(int P,int D,char m)   /*模糊运算引擎*/
{
           
    int PFF[4]={30,60,120,180};      //偏差的变化范围，从左向右为ZO，PS，PM，PL    
    int DFF[4]={5,10,15,25};       //偏差微分的变化范围，从左向右为ZO，PS，PM，PL
 /********************************************************************************************/
 //               输出函数的隶属度，决定了输出的强弱
 /********************************************************************************************/
    int UFF[7][5]={
            
                  {15,20,25,30,35},  //我的20，
                  {25,15,25,60,95},//我的  25
                 {25,40,50,75,100},//2档正跑，弯道65
                 {90,70,60,60,55},//3档反跑，弯道65  欧姆弯要有足够大的摩擦力，要自己去擦！！！
                 {90,60,60,60,50},//{90,70,70,60,50} //4档参数
                 {80,63,37,20,10},
                 {90,70,50,50,50} //12.7，70,65 7.22不错
    };        
         
/********************************************************************************************/
//            规则表，根据自己的思想进行改进
/********************************************************************************************/   
int rule[7][7]={
//变化  -3,-2,-1, 0, 1, 2, 3  // 误差
        {3, 3, 2, 2, 1, 1, 0},   //   -3
        {3, 3, 2, 2, 1, 1, 0},   //   -2
        {3, 3, 2, 2, 1, 1, 0},   //   -1
        {3, 3, 2, 2, 1, 1, 0},   //    0
        {3, 3, 2, 2, 1, 1, 0},   //    1
        {3, 3, 2, 2, 1, 1, 0},   //    2
        {3, 3, 2, 2, 1, 1, 0}};   //    3





    int    U=0;                                      /*偏差,偏差微分以及输出值的精确量*/
    unsigned int   PF[2]={0},DF[2]={0},UF[4]={0};   /*偏差,偏差微分以及输出值的隶属度*/
    
    
    int    Pn=0,Dn=0,Un[4]={0};
    int   t1=0,t2=0,t3=0,t4=0,temp1=0,temp2=0;        //中间值


    /*隶属度的确定*/
    /*根据PD的指定语言值获得有效隶属度*/

    if(P>=-PFF[3] && P<=PFF[3])
    {   
        if(P<=-PFF[2])
        {
            Pn=-2;
            PF[0]=(int)(FMAX*((float)(-PFF[2]-P)/(PFF[3]-PFF[2])));
        }
        else if(P<=-PFF[1])
        {
            Pn=-1;
            PF[0]=(int)(FMAX*((float)(-PFF[1]-P)/(PFF[2]-PFF[1])));
        }
        else if(P<=PFF[0])
        {
            Pn=0;
            PF[0]=(int)(FMAX*((float)(-PFF[0]-P)/(PFF[1]-PFF[0])));
        }
        else if(P<=PFF[1])
        {
            Pn=1;
            PF[0]=(int)(FMAX*((float)(PFF[1]-P)/(PFF[1]-PFF[0])));
        }
        else if(P<=PFF[2])
        {
            Pn=2;
            PF[0]=(int)(FMAX*((float)(PFF[2]-P)/(PFF[2]-PFF[1])));
        }
        else if(P<=PFF[3])
        {
            Pn=3;
            PF[0]=(int)(FMAX*((float)(PFF[3]-P)/(PFF[3]-PFF[2])));
        }
        
    }
    else if(P<=-PFF[3])
    {
        Pn=-2;
        PF[0]=FMAX;
    }
    else
    {
        Pn=3;
        PF[0]=0;
    }
    PF[1]=FMAX-PF[0];         //偏差的隶属度确定完成
    
     //求偏差变化的隶属度
    if(D>=-DFF[3]&&D<=DFF[3])
    {   if(D<=-DFF[2]) 
        {
            Dn=-2;
            DF[0]=(int)(DMAX*((float)(-DFF[2]-D)/(DFF[3]-DFF[2])));
        } 
        else if(D<=-DFF[1]) 
        {
            Dn=-1;
            DF[0]=(int)(DMAX*((float)(-DFF[1]-D)/(DFF[2]-DFF[1]))); 
        }
        else if(D<=DFF[0])
        {
            Dn=0;
            DF[0]=(int)(DMAX*((float)(-DFF[0]-D)/(DFF[1]-DFF[0])));
        }
        else if(D<=DFF[1])
        {
            Dn=1;
            DF[0]=(int)(DMAX*((float)(DFF[1]-D)/(DFF[1]-DFF[0])));
        }
       else if(D<=DFF[2])
        {
            Pn=2;
            PF[0]=(int)(DMAX*((float)(DFF[2]-D)/(DFF[2]-DFF[1])));
        }
        else if(D<=DFF[3])
        {
            Pn=3;
            PF[0]=(int)(DMAX*((float)(DFF[3]-D)/(DFF[3]-DFF[2])));
        }
    }
    else if (D<=-DFF[3])
    {
        Dn=-2;
        DF[0]=DMAX;
    } 
    else 
    {
        Dn=3;
        DF[0]=0;
    }
    DF[1]=FMAX-DF[0];
    
    
    
    /*使用误差范围优化后的规则表rule[7][7]*/
    /*输出值使用13个隶属函数,中心值由UFF[7]指定*/
    /*一般都是四个规则有效*/
 /********************************************************************************************/
//      输出P的语言变量，为  0或1或2或3  ，并确定对应的隶属度fu[n]         
/********************************************************************************************/   
    
    Un[0]=rule[Pn-1+3][Dn-1+3];
    Un[1]=rule[Pn+3][Dn-1+3];
    Un[2]=rule[Pn-1+3][Dn+3];
    Un[3]=rule[Pn+3][Dn+3];
   
   /*确定确信度*/ 
                               
    if(PF[0]<=DF[0])
        UF[0]=PF[0];
    else
        UF[0]=DF[0];
    if(PF[1]<=DF[0])
        UF[1]=PF[1];
    else
        UF[1]=DF[0];
    if(PF[0]<=DF[1])
        UF[2]=PF[0];
    else
        UF[2]=DF[1];
    if(PF[1]<=DF[1])
        UF[3]=PF[1];
    else
        UF[3]=DF[1];
    


 /*同隶属函数输出语言值求大*/
   
   if(Un[0]==Un[1])
    {
        if(UF[0]>UF[1])
            UF[1]=0;
        else
            UF[0]=0;
    }
    if(Un[0]==Un[2])
    {
        if(UF[0]>UF[2])
            UF[2]=0;
        else
            UF[0]=0;
    }
    if(Un[0]==Un[3])
    {
        if(UF[0]>UF[3])
            UF[3]=0;
        else
            UF[0]=0;
    }
    if(Un[1]==Un[2])
    {
        if(UF[1]>UF[2])
            UF[2]=0;
        else
            UF[1]=0;
    }
    if(Un[1]==Un[3])
    {
        if(UF[1]>UF[3])
            UF[3]=0;
        else
            UF[1]=0;
    }
    if(Un[2]==Un[3])
    {
        if(UF[2]>UF[3])
            UF[3]=0;
        else
            UF[2]=0;
    }
   
   
    /*重心法反模糊*/
    /*Un[]原值为输出隶属函数标号，转换为隶属函数值*/
    if(Un[0]>=0)   Un[0]=UFF[m][Un[0]];
    else           Un[0]=-UFF[m][-Un[0]];
    if(Un[1]>=0)   Un[1]=UFF[m][Un[1]];
    else           Un[1]=-UFF[m][-Un[1]];
    if(Un[2]>=0)   Un[2]=UFF[m][Un[2]];
    else           Un[2]=-UFF[m][-Un[2]];
    if(Un[3]>=0)   Un[3]=UFF[m][Un[3]];
    else           Un[3]=-UFF[m][-Un[3]];
    
   
   
    t1=UF[0]*Un[0];
    t2=UF[1]*Un[1];
    t3=UF[2]*Un[2];
    t4=UF[3]*Un[3];
    temp1=t1+t2+t3+t4;
    temp2=UF[0]+UF[1]+UF[2]+UF[3];
    U=temp1/temp2;
    return U;
}




int   Fuzzy_kd(int P,int D,char m)   /*模糊运算引擎*/
{
  int PFF[4]={30,90,120,180};        //偏差的变化范围，从左向右为ZO，PS，PM，PL
  int DFF[4]={10,20,30,40};          //偏差微分的变化范围，从左向右为ZO，PS，PM，PL
  int UFF[7][5]={
    {20,40,60,80,90},//0档保底
    {45, 40, 35, 25, 25},//1档正跑 弯道60
    {50, 90, 70, 50, 40},//2档反跑 弯道65
    {50, 90, 70, 50, 40},//3档反跑弯道65
    {50, 60, 40, 35, 35},//4档
    {30, 30, 30, 30, 30},
    {90, 75, 60, 50, 40}//12.7,70,65
     };
  
    
  int rule[7][7]={
//变化  -3,-2,-1, 0, 1, 2, 3  // 误差
        {3, 3, 3, 3, 2, 1, 0},   //   -3
        {3, 3, 2, 2, 1, 0, 0},   //   -2
        {3, 2, 2, 1, 0, 0, 1},   //   -1
        {2, 1, 1, 0, 1, 1, 2},   //    0
        {1, 0, 0, 1, 2, 2, 3},   //    1
        {0, 0, 1, 2, 2, 3, 3},   //    2
        {0, 1, 2, 3, 3, 3, 3}};   //    3

    
    int    U=0;           /*偏差,偏差微分以及输出值的精确量*/
    unsigned int   PF[2]={0},DF[2]={0},UF[4]={0};   /*偏差,偏差微分以及输出值的隶属度*/
    int    Pn=0,Dn=0,Un[4]={0};
    int   t1=0,t2=0,t3=0,t4=0,temp1=0,temp2=0;


    /*隶属度的确定*/
    /*根据PD的指定语言值获得有效隶属度*/
    if(P>=-PFF[3] && P<=PFF[3])
    {   /*if(P<=-PFF[3])
        {
          Pn=-3;
          PF[0]=FMAX*((float)(-PFF[3]-P)/(PFF[4]-PFF[3]));
        } 
        else*/ if(P<=-PFF[2])
        {
            Pn=-2;
            PF[0]=(int)(FMAX*((float)(-PFF[2]-P)/(PFF[3]-PFF[2])));
        }
        else if(P<=-PFF[1])
        {
            Pn=-1;
            PF[0]=(int)(FMAX*((float)(-PFF[1]-P)/(PFF[2]-PFF[1])));
        }
        else if(P<=PFF[0])
        {
            Pn=0;
            PF[0]=(int)(FMAX*((float)(-PFF[0]-P)/(PFF[1]-PFF[0])));
        }
        else if(P<=PFF[1])
        {
            Pn=1;
            PF[0]=(int)(FMAX*((float)(PFF[1]-P)/(PFF[1]-PFF[0])));
        }
        else if(P<=PFF[2])
        {
            Pn=2;
            PF[0]=(int)(FMAX*((float)(PFF[2]-P)/(PFF[2]-PFF[1])));
        }
        else if(P<=PFF[3])
        {
            Pn=3;
            PF[0]=(int)(FMAX*((float)(PFF[3]-P)/(PFF[3]-PFF[2])));
        }
        /*else if(P<=PFF[4])
        {
            Pn=4;
            PF[0]=FMAX*((float)(PFF[4]-P)/(PFF[4]-PFF[3]));
        } */
    }
    else if(P<=-PFF[3])
    {
        Pn=-2;
        PF[0]=FMAX;
    }
    else
    {
        Pn=3;
        PF[0]=0;
    }
    PF[1]=FMAX-PF[0];         //偏差的隶属度确定完成
   
    //求偏差变化的隶属度
    if(D>=-DFF[3]&&D<=DFF[3])
    {   if(D<=-DFF[2]) 
        {
            Dn=-2;
            DF[0]=(int)(DMAX*((float)(-DFF[2]-D)/(DFF[3]-DFF[2])));
        } 
        else if(D<=-DFF[1]) 
        {
            Dn=-1;
            DF[0]=(int)(DMAX*((float)(-DFF[1]-D)/(DFF[2]-DFF[1]))); 
        }
        else if(D<=DFF[0])
        {
            Dn=0;
            DF[0]=(int)(DMAX*((float)(-DFF[0]-D)/(DFF[1]-DFF[0])));
        }
        else if(D<=DFF[1])
        {
            Dn=1;
            DF[0]=(int)(DMAX*((float)(DFF[1]-D)/(DFF[1]-DFF[0])));
        }
       else if(D<=DFF[2])
        {
            Pn=2;
            PF[0]=(int)(DMAX*((float)(DFF[2]-D)/(DFF[2]-DFF[1])));
        }
        else if(D<=DFF[3])
        {
            Pn=3;
            PF[0]=(int)(DMAX*((float)(DFF[3]-D)/(DFF[3]-DFF[2])));
        }
    }
    else if (D<=-DFF[3])
    {
        Dn=-2;
        DF[0]=FMAX;
    } 
    else 
    {
        Dn=3;
        DF[0]=0;
    }
    DF[1]=FMAX-DF[0];
    /*使用误差范围优化后的规则表rule[7][7]*/
    /*输出值使用13个隶属函数,中心值由UFF[7]指定*/
    /*一般都是四个规则有效*/
    Un[0]=rule[Pn-1+3][Dn-1+3];
    Un[1]=rule[Pn+3][Dn-1+3];
    Un[2]=rule[Pn-1+3][Dn+3];
    Un[3]=rule[Pn+3][Dn+3];
    if(PF[0]<=DF[0])
        UF[0]=PF[0];
    else
        UF[0]=DF[0];
    if(PF[1]<=DF[0])
        UF[1]=PF[1];
    else
        UF[1]=DF[0];
    if(PF[0]<=DF[1])
        UF[2]=PF[0];
    else
        UF[2]=DF[1];
    if(PF[1]<=DF[1])
        UF[3]=PF[1];
    else
        UF[3]=DF[1];
    /*同隶属函数输出语言值求大*/

    if(Un[0]==Un[1])
    {
        if(UF[0]>UF[1])
            UF[1]=0;
        else
            UF[0]=0;
    }
    if(Un[0]==Un[2])
    {
        if(UF[0]>UF[2])
            UF[2]=0;
        else
            UF[0]=0;
    }
    if(Un[0]==Un[3])
    {
        if(UF[0]>UF[3])
            UF[3]=0;
        else
            UF[0]=0;
    }
    if(Un[1]==Un[2])
    {
        if(UF[1]>UF[2])
            UF[2]=0;
        else
            UF[1]=0;
    }
    if(Un[1]==Un[3])
    {
        if(UF[1]>UF[3])
            UF[3]=0;
        else
            UF[1]=0;
    }
    if(Un[2]==Un[3])
    {
        if(UF[2]>UF[3])
            UF[3]=0;
        else
            UF[2]=0;
    }
    /*重心法反模糊*/
    /*Un[]原值为输出隶属函数标号，转换为隶属函数值*/
    if(Un[0]>=0) Un[0]=UFF[m][Un[0]];
    else Un[0]=-UFF[m][-Un[0]];
    if(Un[1]>=0) Un[1]=UFF[m][Un[1]];
    else Un[1]=-UFF[m][-Un[1]];
    if(Un[2]>=0) Un[2]=UFF[m][Un[2]];
    else Un[2]=-UFF[m][-Un[2]];
    if(Un[3]>=0) Un[3]=UFF[m][Un[3]];
    else Un[3]=-UFF[m][-Un[3]];

    t1=UF[0]*Un[0];
    t2=UF[1]*Un[1];
    t3=UF[2]*Un[2];
    t4=UF[3]*Un[3];
    temp1=t1+t2+t3+t4;
    //temp1=  (UF[0]*Un[0])+(UF[1]*Un[1])+(UF[2]*Un[2])+(UF[3]*Un[3]);
    temp2=UF[0]+UF[1]+UF[2]+UF[3];
    U=temp1/temp2;
    return U;
} 










int   Fuzzy_s(int P,int D,char m)     /*模糊运算引擎*/
{
           
    int PFF[4]={10,50,90,180};      //偏差的变化范围，从左向右为ZO，PS，PM，PL
    // int DFF[4]={0,5,15,30};     //偏差微分的变化范围，从左向右为ZO，PS，PM，PL
    int DFF[4]={10,20,30,40};
 /********************************************************************************************/
 //               输出函数的隶属度，决定了输出的强弱
 /********************************************************************************************/
    int UFF[7][5]={
                 //{87,68,48,34,24},//0档保底，弯道60
                 {80,80,80,80,80},
                 {85,55,43,28,20},//1档正跑，弯道60
                 {90,70,50,35,25},//2档正跑，弯道65
                 {90,70,60,60,55},//3档反跑，弯道65  欧姆弯要有足够大的摩擦力，要自己去擦！！！
                 {90,60,60,60,50},//{90,70,70,60,50} //4档参数
                 {80,63,37,20,10},
                 {90,70,50,50,50} //12.7，70,65 7.22不错
    };        
         
    
 //此处需要测试不同情况下最适合的P！！！！！！！直道比弯道大？？
/********************************************************************************************/   
    




/********************************************************************************************/
//            规则表，根据自己的思想进行改进
/********************************************************************************************/   
int rule[7][7]={
//变化  -3,-2,-1, 0, 1, 2, 3  // 误差
        {3, 3, 3, 3, 2, 1, 0},   //   -3
        {3, 3, 2, 2, 1, 0, 0},   //   -2
        {3, 2, 2, 1, 0, 0, 1},   //   -1
        {2, 1, 1, 0, 1, 1, 2},   //    0
        {1, 0, 0, 1, 2, 2, 3},   //    1
        {0, 0, 1, 2, 2, 3, 3},   //    2
        {0, 1, 2, 3, 3, 3, 3}};   //    3





    int    U=0;           /*偏差,偏差微分以及输出值的精确量*/
    unsigned int   PF[2]={0},DF[2]={0},UF[4]={0};   /*偏差,偏差微分以及输出值的隶属度*/
    
    
    int    Pn=0,Dn=0,Un[4]={0};
    int   t1=0,t2=0,t3=0,t4=0,temp1=0,temp2=0;  //中间值


    /*隶属度的确定*/
    /*根据PD的指定语言值获得有效隶属度*/

    if(P>=-PFF[3] && P<=PFF[3])
    {   
        if(P<=-PFF[2])
        {
            Pn=-2;
            PF[0]=(int)(FMAX*((float)(-PFF[2]-P)/(PFF[3]-PFF[2])));
        }
        else if(P<=-PFF[1])
        {
            Pn=-1;
            PF[0]=(int)(FMAX*((float)(-PFF[1]-P)/(PFF[2]-PFF[1])));
        }
        else if(P<=PFF[0])
        {
            Pn=0;
            PF[0]=(int)(FMAX*((float)(-PFF[0]-P)/(PFF[1]-PFF[0])));
        }
        else if(P<=PFF[1])
        {
            Pn=1;
            PF[0]=(int)(FMAX*((float)(PFF[1]-P)/(PFF[1]-PFF[0])));
        }
        else if(P<=PFF[2])
        {
            Pn=2;
            PF[0]=(int)(FMAX*((float)(PFF[2]-P)/(PFF[2]-PFF[1])));
        }
        else if(P<=PFF[3])
        {
            Pn=3;
            PF[0]=(int)(FMAX*((float)(PFF[3]-P)/(PFF[3]-PFF[2])));
        }
        
    }
    else if(P<=-PFF[3])
    {
        Pn=-2;
        PF[0]=FMAX;
    }
    else
    {
        Pn=3;
        PF[0]=0;
    }
    PF[1]=FMAX-PF[0];         //偏差的隶属度确定完成
    
     //求偏差变化的隶属度
    if(D>=-DFF[3]&&D<=DFF[3])
    {   if(D<=-DFF[2]) 
        {
            Dn=-2;
            DF[0]=(int)(DMAX*((float)(-DFF[2]-D)/(DFF[3]-DFF[2])));
        } 
        else if(D<=-DFF[1]) 
        {
            Dn=-1;
            DF[0]=(int)(DMAX*((float)(-DFF[1]-D)/(DFF[2]-DFF[1]))); 
        }
        else if(D<=DFF[0])
        {
            Dn=0;
            DF[0]=(int)(DMAX*((float)(-DFF[0]-D)/(DFF[1]-DFF[0])));
        }
        else if(D<=DFF[1])
        {
            Dn=1;
            DF[0]=(int)(DMAX*((float)(DFF[1]-D)/(DFF[1]-DFF[0])));
        }
       else if(D<=DFF[2])
        {
            Pn=2;
            PF[0]=(int)(DMAX*((float)(DFF[2]-D)/(DFF[2]-DFF[1])));
        }
        else if(D<=DFF[3])
        {
            Pn=3;
            PF[0]=(int)(DMAX*((float)(DFF[3]-D)/(DFF[3]-DFF[2])));
        }
    }
    else if (D<=-DFF[3])
    {
        Dn=-2;
        DF[0]=DMAX;
    } 
    else 
    {
        Dn=3;
        DF[0]=0;
    }
    DF[1]=FMAX-DF[0];
    
    
    
    /*使用误差范围优化后的规则表rule[7][7]*/
    /*输出值使用13个隶属函数,中心值由UFF[7]指定*/
    /*一般都是四个规则有效*/
 /********************************************************************************************/
//      输出P的语言变量，为  0或1或2或3  ，并确定对应的隶属度fu[n]         
/********************************************************************************************/   
    
    Un[0]=rule[Pn-1+3][Dn-1+3];
    Un[1]=rule[Pn+3][Dn-1+3];
    Un[2]=rule[Pn-1+3][Dn+3];
    Un[3]=rule[Pn+3][Dn+3];
   
   /*确定确信度*/ 
                               
    if(PF[0]<=DF[0])
        UF[0]=PF[0];
    else
        UF[0]=DF[0];
    if(PF[1]<=DF[0])
        UF[1]=PF[1];
    else
        UF[1]=DF[0];
    if(PF[0]<=DF[1])
        UF[2]=PF[0];
    else
        UF[2]=DF[1];
    if(PF[1]<=DF[1])
        UF[3]=PF[1];
    else
        UF[3]=DF[1];
    


 /*同隶属函数输出语言值求大*/
   
   if(Un[0]==Un[1])
    {
        if(UF[0]>UF[1])
            UF[1]=0;
        else
            UF[0]=0;
    }
    if(Un[0]==Un[2])
    {
        if(UF[0]>UF[2])
            UF[2]=0;
        else
            UF[0]=0;
    }
    if(Un[0]==Un[3])
    {
        if(UF[0]>UF[3])
            UF[3]=0;
        else
            UF[0]=0;
    }
    if(Un[1]==Un[2])
    {
        if(UF[1]>UF[2])
            UF[2]=0;
        else
            UF[1]=0;
    }
    if(Un[1]==Un[3])
    {
        if(UF[1]>UF[3])
            UF[3]=0;
        else
            UF[1]=0;
    }
    if(Un[2]==Un[3])
    {
        if(UF[2]>UF[3])
            UF[3]=0;
        else
            UF[2]=0;
    }
   
   
    /*重心法反模糊*/
    /*Un[]原值为输出隶属函数标号，转换为隶属函数值*/
    if(Un[0]>=0)   Un[0]=UFF[m][Un[0]];
    else           Un[0]=-UFF[m][-Un[0]];
    if(Un[1]>=0)   Un[1]=UFF[m][Un[1]];
    else           Un[1]=-UFF[m][-Un[1]];
    if(Un[2]>=0)   Un[2]=UFF[m][Un[2]];
    else           Un[2]=-UFF[m][-Un[2]];
    if(Un[3]>=0)   Un[3]=UFF[m][Un[3]];
    else           Un[3]=-UFF[m][-Un[3]];
    
   
   
    t1=UF[0]*Un[0];
    t2=UF[1]*Un[1];
    t3=UF[2]*Un[2];
    t4=UF[3]*Un[3];
    temp1=t1+t2+t3+t4;
    temp2=UF[0]+UF[1]+UF[2]+UF[3];
    U=temp1/temp2;
    return U;
}

